This document describes a Broadcast Wave Format (BWF) file in ["literate
binary"][lb] notation, integrating handcrafted binary (expressed as hex code)
with documentation written in [Markdown][Markdown]. Two different
representations can be derived from this document:

 1. A PDF/HTML/Latex ... file, using a Markdown converter like [Pandoc][Pandoc].
 2. A binary BWF file, using the [`lb` tool][lb].

[lb]: https://github.com/marhop/literate-binary
[Markdown]: https://commonmark.org/
[Pandoc]: https://pandoc.org/

# Broadcast Wave Format file example

The [Broadcast Wave Format (BWF)][BWF] is an extension of the [WAVE audio file
format][RIFF] specified by the [European Broadcasting Union (EBU)][EBU]. Its
main feature is one additional chunk, the "Broadcast Audio Extension" (bext)
chunk which contains "the minimum information -- or metadata -- which is
considered necessary for all broadcast applications" according to the [BWF
specification][BWF], page 3.

This example file is not an introduction to the WAVE file format itself but to
the BWF extension. Basic knowledge of the WAVE file format is assumed.

## RIFF, Format and Data chunks

Each WAVE file has at least three sections (called chunks); the RIFF chunk, the
format chunk and the data chunk. Together they make a complete WAVE file.

The RIFF chunk identifies the file format (RIFF/WAVE) and the size of the
remaining data (including the string "WAVE" but excluding the chunk ID "RIFF"
and the size field itself -- should be equal to file size minus 8).

    "RIFF" b8021000 "WAVE"

The format chunk holds technical metadata necessary to decode the byte stream in
the data chunk below. This includes information about the encoding method (or
WAVE format category), the number of channels, the sampling rate, the average
number of bytes per second (number of channels × sampling rate × bytes per
sample), the block alignment (number of channels × bytes per sample), and
finally the bit depth (or bits per sample).

    "fmt "   # chunk ID
    10000000 # chunk size
    0100     # WAVE format category, PCM
    0200     # number of channels, 2
    80bb0000 # sampling rate, 48000 Hz
    00ee0200 # average number of bytes per second, 192000
    0400     # block alignment, 4
    1000     # bits per sample, 16

A sampling rate of 48 kHz and a bit depth of at least 16 bits per sample are
recommended by [EBU Recommendation R85][R85].

The data chunk contains the actual audio data. In this example it holds just
random bytes, leading to random noise.

    "data" 00001000 .{1M}

Note the special syntax used here: The single dot `.` represents one random byte
and the quantifier `{1M}` represents 1 × 2²⁰ repetitions, so `.{1M}` represents
1 MiB of random data.

## Broadcast Audio Extension chunk

The Broadcast Audio Extension (bext) chunk makes the difference between a
regular WAVE file and a Broadcast Wave file. According to [EBU Recommendation
R85][R85] the bext chunk may appear anywhere in the file but it is recommended
to place it before the data chunk containing the audio data. (A recommendation
that is deliberately ignored in this example file in order to first describe the
regular WAVE chunks and then continue with the BWF extension.)

As usual, the chunk starts with chunk ID and chunk size.

    "bext" 8b020000

The chunk data contains a series of descriptive and technical metadata fields:

  * A description of the sound sequence in this file. This is an ASCII string
    with a maximum length of 256 characters. If the string is shorter than that
    it is terminated by a NULL byte and the rest of the field is padded, usually
    with more NULL bytes (summing up to 202 bytes in this example which is
    represented by the special syntax `(00){202}`).

        "Random noise. The interesting part is in the metadata." (00){202}

  * The originator of the audio file. An ASCII string of at most 32 characters.
    Again, NULL-terminated if it is shorter.

        "Martin Hoppenheit" (00){15}

  * A reference allocated by the originating organisation that aims to
    unambiguously identify a BWF file. According to [EBU Recommendation
    R99][R99] this should be a Unique Source Identifier (USID) which is a string
    composed of the following parts:

     1. An ISO 3166 country code like DE or FR, 2 characters.
     2. An organisation code like WDR or ART, 3 characters. These are
        assigned by the EBU.
     3. The serial number identifying the recorder device, 12 characters.
     4. The origination time, 6 digits (HHMMSS). The time should be the same as
        in the next field.
     5. A random number generated by the recorder, 9 digits.

    To avoid undue misuse of existing organisation codes and serial numbers
    these parts are set to X characters in the following example. See the
    above-mentioned EBU recommendation for more realistic USID examples. The
    special syntax `(30-39){9}` represents 9 random ASCII digits.

        "DE" "XXX" "XXXXXXXXXXXX" "120000" (30-39){9}

  * The creation date and time of the audio data.

        "1970-01-01"
        "12:00:00"

    Note that any ASCII character may be used as a separator, however, the BWF
    specification recommends to use only sensible values like `-`, `_`, `:`, `.`
    or a single space character.

  * A time reference i.e., a count of samples from midnight to the first sample
    of the sound sequence in this file. This is an aid for time code generation
    which can be used to synchronize different audio or video files.

    Given the creation time in the previous field and assuming that counting
    starts from 0 this leads to 12 hours × 60 minutes × 60 seconds × 48000
    samples = 2073600000 = 0x7b98a000 which is represented by this little-endian
    byte sequence:

        00a0987b 00000000

  * The BWF version used. See the next two fields for differences between
    versions 0, 1 and 2.

        0100

  * The Unique Material Identifier (UMID), another ID in addition to the USID
    above. The UMID is defined in standard SMPTE ST 330M which is not freely
    available (i.e., free of charge). The following explanations are based on
    [an excerpt][330M] and may be inaccurate.

    The UMID was introduced with version 1 of the Broadcast Wave Format (a
    version 0 file would instead have a sequence of NULL bytes like `(00){64}`
    in this place). It consists of several components:

     1. The "universal label". This identifies the data in this field as a UMID
        in the context of other SMPTE standards defining more general data
        structures, metadata dictionaries, identifiers etc. The first 10 bytes
        are set to fixed values in conformance with these standards (presumably
        -- they aren't freely available either). The remaining two bytes specify
        the material type (0x08 = "single audio component") and the number
        creation method used for the material number and the instance number
        below (top and bottom nibble of 0x00 respectively, which in both cases
        means "no defined method").

            060a2b34010101050101 08 00

     2. The length of the rest of the UMID field. This is either 0x13 for a
        basic UMID or 0x33 for an extended UMID (see below).

            13

     3. The instance number. This is used to distinguish different instances or
        representations of the same material. For example, two files containing
        the same sound sequence but with different sampling rates would have
        different instance numbers. This is similar to the Representation term
        defined by [PREMIS][PREMIS].

            000000

     4. The material number. This is the actual identifier of the material i.e.,
        the sound sequence in this file. In this case it is just a random byte
        sequence and thus a random number. The two files mentioned in the
        previous example containing the same sound sequence but with different
        sampling rates would have the same material number. This is similar to
        the Intellectual Entity term defined by [PREMIS][PREMIS].

            .{16}

    These four components constitute a basic UMID. Appending another 32 bytes
    containing detailed information about things like creation time and
    recording location would make this an extended UMID. If only a basic UMID is
    used in a BWF file like in this example, these bytes should be set to NULL.

        (00){32}

  * Loudness information, but only in a version 2 BWF file. Otherwise just
    another sequence of NULL bytes. (To be honest, I don't have the necessary
    audio engineering knowledge to determine the correct values of this field,
    so I decided to stick with version 1.)

        (00){10}

  * 180 NULL bytes reserved for further extensions in future BWF versions.

        (00){180}

  * The coding history. This is a series of CR/LF terminated ASCII lines where
    each line describes a step in the coding process applied to the audio data,
    like recording of the original file or conversion to another format. [EBU
    Recommendation R98][R98] defines a syntax of comma-separated key/value pairs
    for use in the coding history with keys like coding algorithm (A), sampling
    frequency (F), word length (W), mode (M) or free-form text (T).

        "A=PCM,F=48000,W=16,M=stereo,T=handmade original" 0d0a

As it happens, the overall size of the bext chunk data is odd. In this case
appending a pad byte to the actual chunk data is required by the [WAVE
specification][RIFF], page 11.

    00

[RIFF]: http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/riffmci.pdf
[BWF]: https://tech.ebu.ch/docs/tech/tech3285.pdf
[EBU]: https://www.ebu.ch
[R85]: https://tech.ebu.ch/docs/r/r085.pdf
[R98]: https://tech.ebu.ch/docs/r/r098.pdf
[R99]: https://tech.ebu.ch/docs/r/r099.pdf
[330M]: https://github.com/markreidvfx/pyaaf2/commit/e2ab71faf4cbb7f139cc4d075f2bf02ceae52a8a
[PREMIS]: https://www.loc.gov/standards/premis/
